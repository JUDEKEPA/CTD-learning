## Introduction

When I learn the book 'Computational Thermodynamics: The Calphad Method', I found there is no detailed explanation of
the global minimization algorithm. I want to learn how this achieved by reading the code of pycalphad.

### io module

The function of io module is to convert the .tdb file to equations and conditions executable by codes. I'd like to skip
this part.

### calculation part

I am curious how pycalphad done the calculations while it is really complex to me, I want to start part by part. I think
I can begin with calculate.py file or equilibrium file.

#### Building of model and phase_records

models is the .tdb file after converted into symbolic manipulation expressions. It can be used for calculation 
derivatives with the symbols. It fits the requirement of thermodynamics calculations very well. The process method is
mainly integrated in io part. 

    #pylint: disable=C0103
    # These are standard abbreviations from Thermo-Calc for these quantities
    energy = GM = property(lambda self: self.ast)
    formulaenergy = G = property(lambda self: self.ast * self._site_ratio_normalization)
    entropy = SM = property(lambda self: -self.GM.diff(v.T))
    enthalpy = HM = property(lambda self: self.GM - v.T*self.GM.diff(v.T))
    heat_capacity = CPM = property(lambda self: -v.T*self.GM.diff(v.T, v.T))
    #pylint: enable=C0103
    mixing_energy = GM_MIX = property(lambda self: self.GM - self.endmember_reference_model.GM)
    mixing_enthalpy = HM_MIX = property(lambda self: self.GM_MIX - v.T*self.GM_MIX.diff(v.T))
    mixing_entropy = SM_MIX = property(lambda self: -self.GM_MIX.diff(v.T))
    mixing_heat_capacity = CPM_MIX = property(lambda self: -v.T*self.GM_MIX.diff(v.T, v.T))

Above is the formulas default in model.

    if phase_records is None:
        models = instantiate_models(dbf, comps, active_phases, model=model, parameters=parameters)
        phase_records = build_phase_records(dbf, comps, active_phases, statevar_dict,
                                            models=models, parameters=parameters,
                                            output=output, callables=callables,
                                            build_gradients=False, build_hessians=False,
                                            verbose=kwargs.pop('verbose', False))

#### points generator

The points generated for the calculation is generated by function _sample_phase_constitution

    points = _sample_phase_constitution(mod, sampler_dict[phase_name] or point_sample,
                                                    fixedgrid_dict[phase_name], pdens_dict[phase_name])

step into _sample_phase_constitution

    points = np.concatenate(list(itertools.chain([points], extra_points)))

this code generate points along each endmember(in or not in the same sublattice), it works like this:

![img.png](points generate along endmember edge.png)

#### gibbs energy calculations for generated points

when using debug mode, _compute_phase_values is considered as an important function, after using of this function, the 
'GM' of a set of points can be obtained.

        phase_ds = _compute_phase_values(nonvacant_components, str_statevar_dict,
                                     points, phase_record, output,
                                     maximum_internal_dof, broadcast=broadcast, parameters=parameters,
                                     largest_energy=float(largest_energy), fake_points=fp)


